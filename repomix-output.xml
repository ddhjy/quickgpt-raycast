This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/
  rules/
    comment-style-guide.mdc
    english-comments-rule.mdc
    typescript-type-check.mdc
assets/
  prompts.hjson
  system_prompts.hjson
example/
  prompt/
    .vscode/
      launch.json
    prompt-template.hjson
  script/
    ChatGPT.applescript
src/
  components/
    prompt-actions.tsx
    prompt-list-item.tsx
    prompt-list.tsx
    prompt-options-form.tsx
    temporary-directory-manager.tsx
  hooks/
    use-initial-context.ts
    use-input-history.ts
  managers/
    pins-manager.ts
    prompt-manager.ts
  stores/
    default-action-preference-store.ts
    input-history-store.ts
    temporary-directory-store.ts
  tests/
    placeholder-formatter.test.ts
    prompt-formatting-utils.test.ts
  utils/
    file-system-utils.ts
    ignore-manager.ts
    option-placeholder-utils.ts
    placeholder-formatter.ts
    prompt-formatting-utils.ts
    script-utils.ts
  prompt-lab.tsx
.autogit
.eslintrc.json
.gitignore
.npmrc
.nvmrc
.prettierrc
CHANGELOG.md
jest.config.js
LICENSE
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/english-comments-rule.mdc">
---
description: 
globs: 
alwaysApply: true
---
All generated comments in the project must be in English.

# Your rule content

- You can @ files here
- You can use markdown but dont have to
</file>

<file path=".autogit">
- Commit message should not mention specific file modifications, but rather the functionality that was modified
- Describe why these changes were made, rather than just what was done
</file>

<file path=".eslintrc.json">
{
  "root": true,
  "extends": ["@raycast"]
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules

# Raycast specific files
raycast-env.d.ts

# misc
.DS_Store

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules

# misc
.DS_Store
# ---- Xcode ----
## User settings
xcuserdata/

## Xcode 8 and earlier
*.xcscmblueprint
*.xccheckout

# ---- macOS ----
# General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

# ---- Node ----
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# ---- Swift ----
# Xcode
#
# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore

## User settings
xcuserdata/

## compatibility with Xcode 8 and earlier (ignoring not required starting Xcode 9)
*.xcscmblueprint
*.xccheckout

## compatibility with Xcode 3 and earlier (ignoring not required starting Xcode 4)
build/
DerivedData/
*.moved-aside
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3

## Obj-C/Swift specific
*.hmap

## App packaging
*.ipa
*.dSYM.zip
*.dSYM

## Playgrounds
timeline.xctimeline
playground.xcworkspace

# Swift Package Manager
#
# Add this line if you want to avoid checking in source code from Swift Package Manager dependencies.
# Packages/
# Package.pins
# Package.resolved
# *.xcodeproj
#
# Xcode automatically generates this directory with a .xcworkspacedata file and xcuserdata
# hence it is not needed unless you have added a package configuration file to your project
# .swiftpm

.build/

# CocoaPods
#
# We recommend against adding the Pods directory to your .gitignore. However
# you should judge for yourself, the pros and cons are mentioned at:
# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control
#
# Pods/
#
# Add this line if you want to avoid checking in source code from the Xcode workspace
# *.xcworkspace

# Carthage
#
# Add this line if you want to avoid checking in source code from Carthage dependencies.
# Carthage/Checkouts

Carthage/Build/

# Accio dependency management
Dependencies/
.accio/

# fastlane
#
# It is recommended to not store the screenshots in the git repo.
# Instead, use fastlane to re-generate the screenshots whenever they are needed.
# For more information about the recommended setup visit:
# https://docs.fastlane.tools/best-practices/source-control/#source-control

fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots/**/*.png
fastlane/test_output

# Code Injection
#
# After new code Injection tools there's a generated folder /iOSInjectionProject
# https://github.com/johnno1962/injectionforxcode

iOSInjectionProject/
.swiftpm
bun.lockb

raycast-env.d.ts

# Raycast specific files
.raycast-swift-build
raycast-env.d.ts
compiled_raycast_swift
</file>

<file path=".npmrc">
registry=https://registry.npmjs.org/
</file>

<file path=".nvmrc">
22.14.0
</file>

<file path=".prettierrc">
{
  "tabWidth": 2,
  "printWidth": 120,
  "singleQuote": false
}
</file>

<file path="LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="tsconfig.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Node 16",
  "include": ["src/**/*", "raycast-env.d.ts"],
  "compilerOptions": {
    "lib": ["es2021"],
    "module": "commonjs",
    "target": "es2021",
    "strict": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "jsx": "react-jsx",
    "resolveJsonModule": true
  }
}
</file>

<file path=".cursor/rules/comment-style-guide.mdc">
---
description:
globs:
alwaysApply: false
---
# Comment Style Guide

This rule defines the comment style requirements for the codebase.

## General Guidelines

- **All comments must be in English**
- Comments should be clear, concise, and provide meaningful context
- Follow existing comment style patterns in nearby files

## File Header Comments

Use a descriptive JSDoc-style comment at the top of each file:

```typescript
/**
 * This file provides utility functions for [purpose].
 * It supports [key features/capabilities]:
 * - Feature 1
 * - Feature 2
 * - Feature 3
 * 
 * [Any additional important context about the file]
 */
```

## Section Headers

Use simple centered headers for major code sections:

```typescript
/* Types & Constants */

// code here...

/* Utility Functions */

// code here...
```

## Function Documentation

Use JSDoc format for all functions:

```typescript
/**
 * Brief description of what the function does.
 * Additional details if needed.
 * 
 * @param paramName Description of the parameter
 * @param anotherParam Description of another parameter
 * @returns Description of the return value
 */
function exampleFunction(paramName: string, anotherParam: number): ReturnType {
  // implementation
}
```

## Inline Comments

- Use inline comments sparingly for non-obvious code
- Keep inline comments concise and to the point
- Example: `const regex = /pattern/g; // Matches all occurrences of pattern`

## Reference Files

For reference on proper comment style, see:
- [placeholderFormatter.ts](mdc:src/utils/placeholderFormatter.ts)
- [fileSystemUtils.ts](mdc:src/utils/fileSystemUtils.ts)
</file>

<file path=".cursor/rules/typescript-type-check.mdc">
---
description: 
globs: 
alwaysApply: true
---
# TypeScript Type Checking Rule

Before finalizing TypeScript code changes or generating new TypeScript code, please ensure its type correctness by running the following command in the terminal:

`npx tsc --noEmit`

This command will check the entire project for TypeScript errors without generating any output files. This helps catch potential issues early.
</file>

<file path="assets/prompts.hjson">
{
title: Ask
icon: 💡
subprompts: [
{
  icon: 🖥️
  title: "/"
  prefix: "none"
  content: "{{i|s|c}}"

}
{
  icon: 📎
  title: "{{i}}"
  content:
  '''
  {{i}}

  {{s|c}}
  '''
}
{
  icon: ⭕️
  title: 是什么
  content:
  '''
  下列文本中，"{{i|c}}"是什么？

  文本：
  {{s}}
  '''
}
{
  icon: ⭕️
  title: 是什么
  content:
  '''
  {{i|s|c}} 是什么？
  '''
}
]
}
</file>

<file path="example/prompt/.vscode/launch.json">
{
    "version": "0.2.0",
    "configurations": []
}
</file>

<file path="example/script/ChatGPT.applescript">
#!/usr/bin/osascript

on run
    restoreAndActivate("ChatGPT")
    delay 0.2
    pressKeyCommand("n")
    delay 1
    pressKeyCommand("v")
    delay 0.1
    pressKeyReturn()
end run

on restoreAndActivate(appName)
    tell application "System Events"
        if not (exists process appName) then
            do shell script "open -a " & quoted form of appName
            delay 5
        end if
    end tell
    tell application "System Events"
        tell application process appName
            set miniaturizedWindows to every window whose value of attribute "AXMinimized" is true
            repeat with win in miniaturizedWindows
                set value of attribute "AXMinimized" of win to false
            end repeat
        end tell
    end tell

    tell application appName
        activate
    end tell
end restoreAndActivate

on pressKeyCommand(key)
    tell application "System Events" to keystroke key using {command down}
end pressKeyCommand

on pressKeyReturn()
    tell application "System Events" to keystroke return
end 

on pressKeyCommandShift(key)
    tell application "System Events" to keystroke key using {command down, shift down}
end pressKeyCommandShift
</file>

<file path="src/stores/default-action-preference-store.ts">
import { Cache } from "@raycast/api";
⋮----
/**
 * Manages the user's preferred default action (e.g., Copy, Paste, specific script)
 * using Raycast's Cache for persistence.
 */
class DefaultActionPreferenceStore
⋮----
/**
   * Initializes a new instance of the DefaultActionPreferenceStore.
   *
   * @param cache The Raycast Cache instance to use for storage.
   * @param key The cache key under which to store the preference. Defaults to "lastSelectedAction".
   */
constructor(cache: Cache, key = "lastSelectedAction")
⋮----
/**
   * Saves the user's default action preference.
   * @param action The action name.
   */
saveDefaultActionPreference(action: string): void
⋮----
/**
   * Gets the user's default action preference.
   * @returns The action name or undefined.
   */
getDefaultActionPreference(): string | undefined
</file>

<file path="src/tests/placeholder-formatter.test.ts">
import { placeholderFormatter, SpecificReplacements, resolvePlaceholders } from "../utils/placeholder-formatter";
</file>

<file path="src/tests/prompt-formatting-utils.test.ts">
import { findUsedOptionPlaceholders } from "../utils/option-placeholder-utils";
import { PromptProps } from "../managers/prompt-manager";
import { SpecificReplacements } from "../utils/placeholder-formatter";
⋮----
input: "", // Empty input, should fallback to option
⋮----
input: "user input", // Has input, should not fallback to option
⋮----
selection: "", // Empty
clipboard: "clipboard content", // Has value
⋮----
input: "", // Empty, will use defaultStyle
⋮----
// nonExistentOption is not defined in prompt
</file>

<file path="src/utils/file-system-utils.ts">
import path from "path";
import fsPromises from "fs/promises";
import fs from "fs";
import ignoreManager from "./ignore-manager";
⋮----
/**
 * This file provides utility functions for interacting with the file system,
 * including checking for binary/media files, ignored items (like node_modules),
 * and reading directory contents recursively (both sync and async).
 * Uses the unified IgnoreManager for consistent file handling.
 */
⋮----
/**
 * Checks if a file extension indicates a binary or media file type.
 * Uses the unified IgnoreManager for consistent binary file detection.
 *
 * @param fileName The full name or path of the file.
 * @returns True if the extension is in the predefined set, false otherwise.
 */
export const isBinaryOrMediaFile = (fileName: string): boolean =>
⋮----
/**
 * Checks if a file or directory path should be ignored.
 * Uses the unified IgnoreManager for consistent ignore pattern matching.
 *
 * @param itemPath The full path of the file or directory.
 * @param basePath The base path to calculate relative paths from.
 * @returns True if the item should be ignored, false otherwise.
 */
export const isIgnoredItem = (itemPath: string, basePath: string): boolean =>
⋮----
/**
 * Asynchronously and recursively reads the contents of a directory.
 * Constructs a string representation including file paths and their content.
 * Skips ignored items and binary/media files (indicating they were ignored).
 * Handles read errors for individual files.
 *
 * @param dirPath The absolute path to the directory to read.
 * @param basePath The base path used for constructing relative paths in the output string. Initially empty.
 * @returns A promise resolving to a string containing the formatted directory contents.
 */
export const readDirectoryContents = async (dirPath: string, basePath: string = ""): Promise<string> =>
⋮----
/**
 * Synchronously and recursively reads the contents of a directory.
 * Constructs a string representation including file paths and their content.
 * Uses the unified IgnoreManager for consistent ignore pattern matching.
 * Logs warnings for read errors but continues processing.
 *
 * @param dirPath The absolute path to the directory to read.
 * @param basePath The base path used for constructing relative paths in the output string. Initially empty.
 * @returns A string containing the formatted directory contents.
 */
export const readDirectoryContentsSync = (dirPath: string, basePath: string = ""): string =>
</file>

<file path="src/utils/option-placeholder-utils.ts">
import { PromptProps } from "../managers/prompt-manager";
import { SpecificReplacements, getPropertyByPath } from "./placeholder-formatter";
⋮----
/**
 * Find option placeholders that would actually be used in fallback chains given current replacement values.
 * This function simulates the placeholder resolution process to determine which option: directives
 * would be reached and used in the fallback chain.
 *
 * @param prompt The Prompt object to check
 * @param replacements Current replacement values (to determine which fallbacks would be used)
 * @returns Array of option property names that would actually be used
 */
export function findUsedOptionPlaceholders(prompt: PromptProps, replacements: SpecificReplacements): string[]
⋮----
// Define placeholder alias mapping locally for this function
⋮----
const toPlaceholderKey = (p: string): keyof SpecificReplacements | undefined =>
⋮----
// Check if it's a valid key
⋮----
// Build effective replacement map like in placeholderFormatter
⋮----
// Regex to find all placeholders including fallback chains
⋮----
// Only process placeholders without directives (potential fallback chains)
⋮----
// Check if this contains a fallback chain
⋮----
// Check if this part has an option directive
⋮----
// Check if this option would be reached (i.e., all previous parts in chain are empty)
⋮----
// Check if previous part has value
⋮----
// Skip directive parts in fallback evaluation for simplicity
⋮----
// Check if it's a standard placeholder with value
⋮----
// Verify the option exists and has values in the prompt
⋮----
break; // Found the option that would be used in this chain
⋮----
// Direct option placeholder
⋮----
// Return after deduplication
</file>

<file path="jest.config.js">

</file>

<file path="example/prompt/prompt-template.hjson">
{
  title: "Writing Assistant"
  icon: "✍️"
  identifier: "writing-assistant-demo"
  
  // Main prompt with placeholders
  content: '''
    As a professional writing assistant, help me {{option:task}} the following text:
    
    {{i|s|c}}
    
    Style: {{style}}
    Tone: {{tone}}
  '''
  
  // Properties that can be referenced
  style: "Clear and concise"
  tone: "Professional yet friendly"
  
  // Dynamic options
  task: [
    "improve"
    "proofread"
    "summarize"
    "expand"
    "translate"
  ]
  
  // Prefix/suffix properties
  prefix: "requirements,context"
  suffix: "signature"
  
  requirements: "Please maintain the original meaning while enhancing clarity"
  context: "Target audience: General readers"
  signature: "Enhanced by AI Writing Assistant"
  
  // Custom actions
  actions: ["Copy", "Paste", "Grammar Check"]
  
  // Nested subprompts
  subprompts: [
    {
      title: "Email Composer"
      icon: "📧"
      identifier: "email-composer"
      content: '''
        Compose a professional email based on:
        
        Purpose: {{i}}
        Key points: {{s|c}}
        
        Recipient: {{option:recipient}}
      '''
      recipient: {
        "Colleague": "informal but professional"
        "Manager": "formal and respectful"
        "Client": "professional and courteous"
      }
    }
    {
      title: "Blog Post Optimizer"
      icon: "📝"
      content: '''
        Optimize this blog post for SEO and readability:
        
        {{s|c}}
        
        Target keywords: {{i}}
        Reading level: {{readingLevel}}
      '''
      readingLevel: "Intermediate (8th grade)"
      textInputs: {
        "targetKeywords": "Enter your target keywords"
        "metaDescription": "Write a meta description (150-160 chars)"
      }
    }
    {
      title: "Creative Writing Helper"
      icon: "🎨"
      identifier: "creative-writing"
      subprompts: [
        {
          title: "Character Development"
          content: '''
            Help me develop a character with these traits:
            {{i|s|c}}
            
            Include: {{option:aspects}}
          '''
          aspects: [
            "Physical appearance"
            "Personality traits"
            "Background story"
            "Motivations and goals"
            "Strengths and weaknesses"
          ]
        }
        {
          title: "Plot Generator"
          content: '''
            Generate a plot outline for a {{option:genre}} story with:
            
            Main theme: {{i}}
            Setting: {{s|c}}
          '''
          genre: [
            "Mystery"
            "Science Fiction"
            "Romance"
            "Fantasy"
            "Thriller"
          ]
        }
      ]
    }
    {
      title: "Quick Templates"
      icon: "⚡"
      subprompts: [
        {
          title: "Fix Grammar"
          prefix: ""
          content: "Fix grammar and punctuation: {{i|s|c}}"
        }
        {
          title: "Make Concise"
          prefix: ""
          content: "Make this more concise: {{i|s|c}}"
        }
        {
          title: "Add Examples"
          content: '''
            Add relevant examples to illustrate this concept:
            {{i|s|c}}
          '''
        }
      ]
    }
    // These examples demonstrate the new fallback chain functionality with option: and file: directives
    {
      title: "Smart Content Generator"
      icon: "🤖"
      identifier: "smart-content-generator"
      content: '''
        Generate content based on:
        
        Input: {{i|option:defaultInputTypes}}
        Style: {{selection|option:stylePresets}}
        Template: {{clipboard|file:./templates/default.md}}
        
        Additional context: {{i|file:./context/default.txt|option:fallbackContext}}
      '''
      
      // These options will only show Configure Options when actually needed
      defaultInputTypes: ["article", "blog post", "email", "report"]
      stylePresets: ["professional", "casual", "technical", "creative"]
      fallbackContext: ["No additional context needed", "Use general guidelines"]
      
      // Demonstrates: 
      // - {{i|option:defaultInputTypes}} - shows options only if input is empty
      // - {{selection|option:stylePresets}} - shows options only if selection is empty  
      // - {{clipboard|file:...}} - file fallback when clipboard is empty
      // - {{i|file:...|option:...}} - complex 3-level fallback chain
    }
    {
      title: "Adaptive Translator"
      icon: "🌐"
      identifier: "adaptive-translator"
      content: '''
        Translate the following text:
        
        Source: {{i|s|c|file:./input/sample.txt}}
        Target language: {{input|option:languages}}
        Tone: {{selection|option:tones|file:./presets/tone.txt}}
        
        Special instructions: {{clipboard|option:instructions}}
      '''
      
      languages: ["English", "Chinese", "Japanese", "French", "Spanish"]
      tones: ["formal", "informal", "business", "friendly"]
      instructions: ["Keep original formatting", "Adapt cultural references", "Maintain technical terms"]
      
      // Demonstrates:
      // - {{i|s|c|file:...}} - 4-level fallback with file at end
      // - {{input|option:languages}} - using full name instead of alias
      // - {{selection|option:...|file:...}} - option + file fallback
      // - Smart Configure Options only when fallback reaches option
    }
    {
      title: "Document Processor" 
      icon: "📄"
      identifier: "document-processor"
      content: '''
        Process this document:
        
        Content: {{s|file:./documents/template.md|option:sampleContent}}
        Processing type: {{i|option:processingTypes}}
        Output format: {{clipboard|option:outputFormats|file:./formats/default.txt}}
        
        Quality level: {{selection|option:qualityLevels}}
      '''
      
      sampleContent: ["No content provided", "Please select or provide content"]
      processingTypes: ["summarize", "rewrite", "format", "analyze"]
      outputFormats: ["markdown", "plain text", "HTML", "PDF-ready"]
      qualityLevels: ["quick", "standard", "detailed", "comprehensive"]
      
      // Demonstrates complex fallback scenarios:
      // - File as middle fallback option
      // - Multiple independent option chains
      // - Different fallback depths for different placeholders
    }
    {
      title: "Code Assistant"
      icon: "💻"  
      identifier: "code-assistant"
      content: '''
        Help with this code:
        
        Code: {{s|c|file:./code/example.js}}
        Language: {{i|option:languages|file:./config/default-lang.txt}}
        Task: {{input|option:tasks}}
        Style guide: {{clipboard|file:./styles/coding-style.md|option:styleGuides}}
      '''
      
      languages: ["JavaScript", "Python", "TypeScript", "Java", "Go"]
      tasks: ["review", "optimize", "debug", "document", "refactor"]
      styleGuides: ["Google Style", "Airbnb Style", "Standard", "Custom"]
      
      // Demonstrates:
      // - Mixed file and option fallbacks
      // - Different alias usage (i vs input)
      // - Real-world code assistance scenario
    }
    {
      title: "Meeting Notes Assistant"
      icon: "📝"
      identifier: "meeting-notes"
      content: '''
        Process these meeting notes:
        
        Notes: {{s|c|option:sampleNotes}}
        Meeting type: {{i|option:meetingTypes}}
        Output style: {{selection|file:./templates/meeting-format.md|option:outputStyles}}
        
        Action items format: {{clipboard|option:actionFormats}}
      '''
      
      sampleNotes: ["No notes provided - please add meeting content"]
      meetingTypes: ["standup", "planning", "review", "brainstorming", "client meeting"]
      outputStyles: ["summary", "detailed", "action-focused", "executive brief"]
      actionFormats: ["bullet points", "numbered list", "table", "checkbox list"]
      
      // Demonstrates:
      // - Option as first fallback (for required content)
      // - File in middle of chain
      // - Different fallback strategies for different fields
    }
  ]
  
  // File reference examples
  ref: {
    "styleGuide": "{{file:./writing-style-guide.md}}"
    "templates": "{{file:./templates/}}"
  }

}
</file>

<file path="src/components/prompt-options-form.tsx">
import { useState, useEffect, useRef } from "react";
import { Form, ActionPanel, useNavigation } from "@raycast/api";
import { generatePromptActions } from "./prompt-actions";
import { getPropertyByPath } from "../utils/placeholder-formatter";
import { PromptProps } from "../managers/prompt-manager";
import { ScriptInfo } from "../utils/script-utils";
import { SpecificReplacements } from "../utils/placeholder-formatter";
⋮----
interface OptionsFormProps {
  prompt: PromptProps;
  optionKeys?: string[];
  baseReplacements: Omit<SpecificReplacements, "clipboard">;
  promptSpecificRootDir?: string;
  scripts: ScriptInfo[];
}
⋮----
/**
 * Component that renders a form for prompts requiring user-configurable options (dropdowns, text inputs).
 *
 * @param props The component props.
 * @param props.prompt The prompt data, including defined options and text inputs.
 * @param props.optionKeys List of option property names, used for dynamic option generation (new)
 * @param props.baseReplacements Base replacements without clipboard.
 * @param props.promptSpecificRootDir Root directory for file placeholder resolution.
 * @param props.scripts List of available scripts for the action panel.
 */
⋮----
// Initialize default values for options
⋮----
// Handle options referenced by option:xxx
⋮----
// Select the first option by default
⋮----
// Handle the traditional options object
⋮----
/**
   * Handles changes to dropdown form elements.
   * Updates the state with the selected dropdown value.
   *
   * @param key The key (identifier) of the dropdown being changed.
   * @param newValue The newly selected value.
   */
const handleDropdownChange = (key: string, newValue: string) =>
⋮----
/**
   * Handles changes to text field form elements.
   * Updates the state with the entered text value.
   *
   * @param key The key (identifier) of the text field being changed.
   * @param newValue The newly entered text.
   */
const handleTextFieldChange = (key: string, newValue: string) =>
⋮----
{/* Dynamically generate dropdown menus from properties specified by optionKeys */}
⋮----
{/* Dropdown menus generated from the traditional options object */}
⋮----
onChange=
⋮----
{/* Text input fields */}
</file>

<file path="src/components/temporary-directory-manager.tsx">
import React, { useState, useEffect } from "react";
import {
  List,
  ActionPanel,
  Action,
  Icon,
  showToast,
  Toast,
  getSelectedFinderItems,
  Alert,
  confirmAlert,
  Color,
} from "@raycast/api";
import path from "path";
import fs from "fs";
import {
  getActiveTemporaryDirectoriesWithExpiry,
  addTemporaryDirectory,
  removeTemporaryDirectory,
  removeAllTemporaryDirectories,
  TemporaryDirectoryWithExpiry,
} from "../stores/temporary-directory-store";
import promptManager from "../managers/prompt-manager";
⋮----
interface TemporaryDirectoryManagerProps {
  onRefreshNeeded: () => void;
}
⋮----
/**
 * Component for managing temporary prompt directories.
 * Displays a list of active temporary directories with their expiration times,
 * and provides actions to add, remove, and manage them.
 */
⋮----
// Refresh temporary directories list
const refreshDirectories = () =>
⋮----
// Update every second to refresh remaining time
⋮----
// Handle adding new temporary directory
const handleAddDirectory = async () =>
⋮----
// Handle removing a temporary directory
const handleRemoveDirectory = async (dirPath: string) =>
⋮----
// Handle removing all temporary directories
const handleRemoveAll = async () =>
</file>

<file path="src/hooks/use-input-history.ts">
import { useState, useEffect, useCallback } from "react";
import inputHistoryStore from "../stores/input-history-store";
⋮----
/**
 * Custom hook for managing input history navigation
 * Provides functionality to navigate through history with keyboard
 */
export function useInputHistory(initialValue: string = "")
⋮----
// Save current input if we're at the beginning
⋮----
// Navigate down
⋮----
// Restore temporary input or clear
</file>

<file path="src/managers/pins-manager.ts">
import { Cache } from "@raycast/api";
⋮----
/**
 * Manages the persistence of pinned prompt identifiers using Raycast's Cache.
 * Allows pinning and unpinning prompts by their unique identifier, maintaining pin order.
 */
class PinsManager
⋮----
/**
   * Initializes a new instance of the PinsManager.
   *
   * @param cache The Raycast Cache instance to use for storage.
   * @param key The cache key under which to store the pinned identifiers. Defaults to "pinnedIdentifiers".
   */
constructor(cache: Cache, key = "pinnedIdentifiers")
⋮----
/**
   * Adds an identifier to the beginning of the pinned list, ensuring uniqueness.
   * @param identifier The identifier to pin.
   */
pin(identifier: string): void
⋮----
/**
   * Removes an identifier from the pinned list.
   * @param identifier The identifier to unpin.
   */
unpin(identifier: string): void
⋮----
/**
   * Gets all pinned identifiers in the order they were pinned (most recent first).
   * @returns An array of pinned identifiers.
   */
pinnedIdentifiers(): string[]
</file>

<file path="src/stores/input-history-store.ts">
import { Cache } from "@raycast/api";
⋮----
/**
 * Manages input history using Raycast's Cache
 * Stores previously entered input values for quick access
 */
class InputHistoryStore
⋮----
constructor(cache: Cache, key = "inputHistory", maxSize = 50)
⋮----
/**
   * Add new input to history (avoiding duplicates)
   */
addToHistory(input: string): void
⋮----
// Remove existing entry if present
⋮----
// Add to beginning
⋮----
// Limit size
⋮----
/**
   * Get all history items
   */
getHistory(): string[]
⋮----
/**
   * Clear all history
   */
clearHistory(): void
⋮----
/**
   * Remove specific item from history
   */
removeFromHistory(input: string): void
</file>

<file path="assets/system_prompts.hjson">
{
  // System-level prompts like Settings
  title: "Settings"
  icon: "⚙️"
  identifier: "settings" // Unique identifier for the settings root
  pinned: true // Keep settings easily accessible
  subprompts: [
    {
      title: "Open Extension Preferences"
      icon: ""
      identifier: "open-preferences"
      actions: ["open-preferences"] // Action to trigger opening preferences
    }
    {
      title: "Open Scripts Directory"
      icon: ""
      identifier: "open-scripts-dir"
      actions: ["open-scripts-dir"] // Action to open the scripts directory
    }
    {
      title: "Open Custom Prompts Directory"
      icon: ""
      identifier: "open-custom-prompts-dir"
      actions: ["open-custom-prompts-dir"] // Action to open the custom prompts directory
    }
    {
      title: "Manage Temporary Prompt Directory"
      icon: "Clock"
      identifier: "manage-temporary-directory"
      // No content, actions handled specially in PromptListItem
    }
  ]
}
</file>

<file path="src/stores/temporary-directory-store.ts">
import { Cache, showToast, Toast } from "@raycast/api";
⋮----
const EXPIRY_DURATION = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds
⋮----
export interface TemporaryDirectoryInfo {
  path: string;
  addedAt: number;
  lastUsedAt: number;
}
⋮----
export interface TemporaryDirectoryWithExpiry extends TemporaryDirectoryInfo {
  remainingMs: number;
  remainingText: string;
}
⋮----
// Calculate remaining time for directory
export function calculateRemainingTime(dirInfo: TemporaryDirectoryInfo): TemporaryDirectoryWithExpiry
⋮----
// Get list of all active temporary directories with expiration information
export function getActiveTemporaryDirectoriesWithExpiry(): TemporaryDirectoryWithExpiry[]
⋮----
// Get list of all active temporary directories
export function getActiveTemporaryDirectories(): TemporaryDirectoryInfo[]
⋮----
// If directories have expired, update the cache
⋮----
// Check if the specified path is already added as a temporary directory
export function isPathInTemporaryDirectories(dirPath: string): boolean
⋮----
// Add a new temporary directory
export function addTemporaryDirectory(dirPath: string): void
⋮----
// Update usage time for specific temporary directory
export function updateTemporaryDirectoryUsage(path: string): void
⋮----
export function updateAnyTemporaryDirectoryUsage(): void
⋮----
// Remove specific temporary directory by path
export function removeTemporaryDirectory(dirPath: string): void
⋮----
// Remove all temporary directories
export function removeAllTemporaryDirectories(): void
⋮----
export function getActiveTemporaryDirectory(): TemporaryDirectoryInfo | null
⋮----
export function setTemporaryDirectory(dirPath: string): void
</file>

<file path="src/utils/script-utils.ts">
import fs from "fs";
import path from "path";
⋮----
/**
 * This file provides utility functions for discovering and managing AppleScript files
 * that can be executed as actions within the QuickGPT extension.
 */
⋮----
/**
 * Interface for script information.
 */
export interface ScriptInfo {
  path: string;
  name: string;
}
⋮----
/**
 * Recursively scans a specified directory to find all AppleScript files
 * (files ending with `.applescript` or `.scpt`).
 * Ignores files and directories starting with `#`.
 *
 * @param dir The absolute path of the directory to scan.
 * @param relativePath The current relative path from the initial directory (used internally for recursion).
 * @param result An array to accumulate the found ScriptInfo objects (used internally for recursion).
 * @returns An array of ScriptInfo objects, each containing the full path and the display name (filename without extension) of a found script.
 */
export function scanScriptsDirectory(dir: string, relativePath = "", result: ScriptInfo[] = []): ScriptInfo[]
⋮----
/**
 * Retrieves a list of all available AppleScript files from the user-configured scripts directories.
 * Handles cases where directories are not configured or are inaccessible.
 *
 * @param scriptsDirectories Array of paths to the user's custom scripts directories, as configured in preferences.
 * @returns An array of ScriptInfo objects for all discovered scripts. Returns an empty array if no directories are set or errors occur.
 */
export function getAvailableScripts(scriptsDirectories: (string | undefined)[]): ScriptInfo[]
⋮----
const scriptNames = new Set<string>(); // Used for deduplication
⋮----
// Avoid duplicate script names
</file>

<file path="src/components/prompt-list.tsx">
import { useState, useMemo, useEffect, useRef } from "react";
import { List, getPreferenceValues, showToast, Toast, clearSearchBar, useNavigation } from "@raycast/api";
import { match } from "pinyin-pro";
import path from "path";
import { PromptProps } from "../managers/prompt-manager";
import promptManager from "../managers/prompt-manager";
import pinsManager from "../managers/pins-manager";
import { MemoizedPromptListItem } from "./prompt-list-item";
import defaultActionPreferenceStore from "../stores/default-action-preference-store";
import { getAvailableScripts, ScriptInfo } from "../utils/script-utils";
import { useInputHistory } from "../hooks/use-input-history";
⋮----
interface PromptListProps {
  prompts: PromptProps[];
  searchMode?: boolean;
  selectionText: string;
  currentApp: string;
  allApp?: string;
  browserContent: string;
  allowedActions?: string[];
  initialScripts?: ScriptInfo[];
  externalOnRefreshNeeded?: () => void;
}
⋮----
/**
 * Component for displaying a list of prompts.
 * Handles search, pinning, dynamic content replacement, and navigation.
 *
 * @param props The component props.
 * @param props.prompts The list of prompts to display.
 * @param props.searchMode Whether the list is in search mode (true) or input mode (false).
 * @param props.selectionText Current selected text content.
 * @param props.currentApp Name of the frontmost application.
 * @param props.browserContent Content fetched from the active browser tab.
 * @param props.allowedActions Optional list of allowed action names for the prompts.
 * @param props.initialScripts Optional initial list of scripts (avoids re-fetching).
 * @param props.externalOnRefreshNeeded Optional callback from parent to trigger a full refresh.
 */
⋮----
// Replace original searchText state with input history hook
⋮----
const forceUpdate = ()
⋮----
const handlePinToggle = (prompt: PromptProps) =>
⋮----
const sortGroup = (group: PromptProps[]): PromptProps[] =>
⋮----
const handleSearchTextChange = (text: string) =>
⋮----
// Reset history navigation when user uses arrow keys to select list items
</file>

<file path="src/hooks/use-initial-context.ts">
import { useState, useEffect } from "react";
import {
  getSelectedText,
  getFrontmostApplication,
  BrowserExtension,
  getSelectedFinderItems,
  getApplications,
} from "@raycast/api";
⋮----
/**
 * Custom hook to fetch initial context information needed for prompts.
 * This includes selected text, frontmost application name,
 * and content from the active browser tab (if applicable).
 *
 * @param initialClipboardText Optional pre-fetched clipboard text (no longer used).
 * @param initialSelectionText Optional pre-fetched selection text.
 * @param target Optional target identifier, used as a dependency to refetch context if needed.
 * @returns An object containing the fetched context data and a loading state indicator:
 *          { selectionText, currentApp, browserContent, isLoading }
 */
export function useInitialContext(initialSelectionText?: string, target?: string)
⋮----
/**
     * Fetches the currently selected text or selected Finder items.
     * Uses initial value if provided.
     * Prioritizes selected Finder items, formatting them as `{{file:path}}` placeholders.
     * Falls back to `getSelectedText()`.
     * Handles potential errors gracefully by returning an empty string.
     *
     * @returns A promise resolving to the selected text/Finder items or an empty string.
     */
const fetchSelectedText = async (): Promise<string> =>
⋮----
/**
     * Fetches the name of the frontmost application.
     *
     * @returns A promise resolving to the application name.
     */
const fetchFrontmostApp = async (): Promise<string> =>
⋮----
/**
     * Fetches the content (Markdown format) of the active browser tab using BrowserExtension API.
     * Handles potential errors (e.g., no browser active, extension not available) gracefully
     * by returning an empty string.
     *
     * @returns A promise resolving to the browser tab content (Markdown) or an empty string.
     */
const fetchBrowserContent = async (): Promise<string> =>
⋮----
/**
     * Fetches the list of all installed applications.
     * Handles potential errors gracefully by returning an empty string.
     *
     * @returns A promise resolving to a comma-separated list of application names.
     */
const fetchAllApps = async (): Promise<string> =>
⋮----
const fetchData = async () =>
</file>

<file path="src/utils/ignore-manager.ts">
import ignore, { Ignore } from "ignore";
import fs from "fs";
import path from "path";
⋮----
/**
 * Singleton class for managing file ignore rules
 * Supports .gitignore files and custom ignore rules
 */
class IgnoreManager
⋮----
/**
   * Generate complete ignore patterns for directories (including the directory itself and its contents)
   */
private generateDirectoryIgnorePatterns(): string[]
⋮----
/**
   * Get all default ignore rules
   */
private get defaultIgnorePatterns(): string[]
⋮----
private constructor()
⋮----
static getInstance(): IgnoreManager
⋮----
/**
   * Get ignore instance for directory (with caching)
   */
getIgnoreForDirectory(dirPath: string): Ignore
⋮----
/**
   * Find all ignore files (.quickgptignore and .gitignore) from root directory to specified directory
   * .quickgptignore files have higher priority than .gitignore files
   */
private findIgnoreFiles(dirPath: string): string[]
⋮----
// Check for .quickgptignore file (higher priority)
⋮----
// Check for .gitignore file
⋮----
/**
   * Check if file should be ignored
   */
shouldIgnore(filePath: string, basePath: string): boolean
⋮----
/**
   * Check if it's a binary file
   */
isBinaryFile(filePath: string): boolean
⋮----
/**
   * Clear cache (call when needed)
   */
clearCache(): void
⋮----
/**
   * Add custom ignore patterns
   */
addCustomIgnorePatterns(patterns: string[]): void
⋮----
/**
   * Add directories to ignore (automatically generates ignore rules for both directory and its contents)
   */
addDirectoriesToIgnore(directories: string[]): void
</file>

<file path="src/managers/prompt-manager.ts">
import md5 from "md5";
import { getPreferenceValues } from "@raycast/api";
⋮----
type Preferences = {
  customPromptsDirectory?: string;
  customPromptsDirectory1?: string;
  customPromptsDirectory2?: string;
  customPromptsDirectory3?: string;
  customPromptsDirectory4?: string;
};
⋮----
export type PromptProps = {
  identifier: string;
  title: string;
  content?: string;
  pattern?: string;
  icon?: string;
  subprompts?: PromptProps[];
  pinned?: boolean;
  prefix?: string;
  suffix?: string;
  noexplanation?: boolean;
  forbidChinese?: boolean;
  ref?: { [key: string]: string | string[] };
  options?: { [key: string]: string[] | Record<string, string> };
  actions?: string[];
  textInputs?: { [key: string]: string };
  path?: string;
  filePath?: string;
  isTemporary?: boolean;
  temporaryDirSource?: string;
};
⋮----
// List of properties that should NOT be inherited from parent to child
⋮----
/**
 * Manages loading, parsing, processing, and accessing prompt templates.
 * Reads prompts from HJSON files located in configured directories or default paths.
 * Handles nested prompts (subprompts) and content loading from external files.
 * Generates unique identifiers for prompts if not provided.
 */
class PromptManager
⋮----
private mergedRootProperties: Partial<PromptProps> = {}; // Stores merged root properties
private temporaryDirectoryPaths: string[] = []; // Modified to store multiple temporary directory paths
⋮----
/**
   * Initializes the PromptManager by determining prompt file paths based on preferences
   * and loading all prompts from those paths.
   */
constructor()
⋮----
/**
   * Determines the list of file and directory paths to load prompts from.
   * Combines default paths, user-configured files, and user-configured directories
   * specified in the extension preferences. Always includes the system prompts file.
   *
   * @param preferences The extension preferences object.
   * @returns An array of absolute file and directory paths.
   */
private getPromptFilePaths(preferences: Preferences): string[]
⋮----
/**
   * Loads and parses prompts from a single HJSON file synchronously.
   * Handles potential file reading or parsing errors.
   * Processes each loaded prompt to load content from external files if specified.
   *
   * @param filePath The absolute path to the HJSON prompt file.
   * @returns An array of PromptProps loaded from the file, or an empty array if an error occurs.
   */
private loadPromptsFromFileSync(filePath: string): PromptProps[]
⋮----
// Merge global default values (later values overwrite earlier ones)
⋮----
// console.log(`Merged rootProperty from ${filePath}`, fileRootProperty); // Optional debug log
⋮----
// eslint-disable-next-line @typescript-eslint/no-unused-vars
⋮----
// Handle actions field: convert string format to array if needed
⋮----
// loadPromptContentFromFileSync remains largely unchanged unless content needs file loading
⋮----
processedPrompt.filePath = filePath; // Assign the file path
⋮----
// Add temporary directory flag and source directory
⋮----
processedPrompt.temporaryDirSource = tempDirSource; // Add temporary directory source to prompt properties
⋮----
/**
   * Loads prompts from all configured file paths.
   * Distinguishes between files and directories, traversing directories recursively.
   * Processes the combined list of prompts after loading.
   */
private loadAllPrompts(): void
⋮----
/**
   * Recursively traverses a directory to find and load prompts from HJSON files.
   * Ignores files starting with '#'.
   *
   * @param directoryPath The absolute path to the directory to traverse.
   * @returns An array of PromptProps found within the directory and its subdirectories.
   */
private traverseDirectorySync(directoryPath: string): PromptProps[]
⋮----
/**
   * Checks if a given file path corresponds to a prompt file (HJSON).
   *
   * @param filePath The path to check.
   * @returns True if the file has a .hjson extension, false otherwise.
   */
private isPromptFile(filePath: string): boolean
⋮----
/**
   * Recursively processes a prompt and its subprompts to load content specified
   * via file paths in the `content` property (if applicable, though current structure might not use this).
   * This method seems primarily focused on processing subprompts recursively.
   *
   * @param prompt The prompt object to process.
   * @param baseDir The base directory for resolving relative file paths (usually the directory of the HJSON file).
   * @returns The processed prompt object.
   */
private loadPromptContentFromFileSync(prompt: PromptProps, baseDir: string): PromptProps
⋮----
/**
   * Processes a list of prompts recursively.
   * Assigns generated identifiers, calculates hierarchical paths, and inherits properties
   * like actions, prefix, icon, and filePath from parent prompts.
   *
   * @param prompts The array of prompts to process.
   * @param parentPrompt Optional parent prompt for context (inheritance, path calculation).
   * @returns The array of processed prompts.
   */
private processPrompts(prompts: PromptProps[], parentPrompt?: PromptProps): PromptProps[]
⋮----
// eslint-disable-next-line @typescript-eslint/no-explicit-any
⋮----
// Handle actions field: convert string format to array if needed
⋮----
/**
   * Processes a single prompt to ensure it has a unique identifier.
   * If no identifier is provided, generates one based on a hash of its title,
   * emojis, and placeholder names.
   *
   * @param prompt The prompt object to process.
   * @returns The processed prompt object with an identifier.
   */
private processPrompt(prompt: PromptProps): PromptProps
⋮----
/**
   * Returns the array of all loaded and processed root-level prompts.
   *
   * @returns An array of PromptProps representing the root prompts.
   */
public getRootPrompts(): PromptProps[]
⋮----
// Filter out any prompts that might be nested as subprompts elsewhere
⋮----
const collectSubpromptIds = (p: PromptProps) =>
⋮----
/**
   * Returns a flattened list of all prompts (including subprompts) that satisfy the filter function.
   *
   * @param filterFn A function that takes a PromptProps object and returns true if it should be included.
   * @returns A flattened array of PromptProps matching the filter.
   */
public getFilteredPrompts(filterFn: (prompt: PromptProps) => boolean): PromptProps[]
⋮----
/**
   * Recursively collects prompts (and subprompts) that satisfy the filter function.
   *
   * @param prompt The current prompt object to check.
   * @param filterFn The filter function.
   * @returns An array of PromptProps matching the filter within this branch of the hierarchy.
   */
private collectFilteredPrompts(prompt: PromptProps, filterFn: (prompt: PromptProps) => boolean): PromptProps[]
⋮----
/**
   * Finds the first prompt (including subprompts) that satisfies the filter function using depth-first search.
   *
   * @param filterFn A function that takes a PromptProps object and returns true if it matches.
   * @returns The first matching PromptProps object, or undefined if no match is found.
   */
public findPrompt(filterFn: (prompt: PromptProps) => boolean): PromptProps | undefined
⋮----
const findRecursively = (promptsToSearch: PromptProps[]): PromptProps | undefined =>
⋮----
/**
   * Reloads all prompts from the configured file paths.
   * This clears the current prompts and re-runs the loading and processing steps.
   */
public reloadPrompts(): void
</file>

<file path="src/utils/prompt-formatting-utils.ts">
import { Icon, List } from "@raycast/api";
import { PromptProps } from "../managers/prompt-manager";
import {
  SpecificReplacements,
  placeholderFormatter,
  resolvePlaceholders,
  getPropertyByPath,
} from "./placeholder-formatter";
import promptManager from "../managers/prompt-manager";
⋮----
/**
 * This file provides utility functions specifically related to formatting and processing
 * prompt content before it's displayed or sent to an AI.
 * Includes handling of prefix commands, resolving quick prompts from context,
 * building the final formatted content with placeholders, and generating UI elements like icons and indented titles.
 */
⋮----
/**
 * Generates placeholder string based on a comma-separated property keys list.
 * Keys listed are directly converted to {{key}} placeholders.
 * Relies on these keys existing as properties in the prompt object (defined in HJSON).
 * No defaults, no validation against a predefined list, no "none", no "!".
 *
 * @param keysList Comma-separated string of property keys (e.g., "myPromptSetting,lang").
 * @param position Specifies placeholder position, affecting how newlines are added. 'prefix' adds trailing newline, 'suffix' adds leading newline.
 * @returns Placeholder string with appropriate newlines based on position parameter.
 */
export function generatePlaceholders(keysList: string | undefined, position: "prefix" | "suffix"): string
⋮----
// Filter out any empty strings resulting from splitting (e.g., "key1,,key2")
.filter((key) => key.length > 0); // Only check for non-empty keys
⋮----
// Ensure uniqueness
⋮----
// If keys list is null, undefined, or empty, activeKeys remains []
⋮----
// Generate placeholder strings using the keys directly
⋮----
// Add newline based on position
⋮----
return placeholderString + (placeholderString.length > 0 ? "\n" : ""); // Add trailing newline if needed
⋮----
// suffix
return (placeholderString.length > 0 ? "\n" : "") + placeholderString; // Add leading newline if needed
⋮----
/**
 * Generates placeholder string based on prefix property.
 * Keys listed in prefix are directly converted to {{key}} placeholders.
 *
 * @param prefix Comma-separated string of property keys (e.g., "myPromptSetting,lang").
 * @returns Placeholder string (e.g., "{{myPromptSetting}}\n{{lang}}\n") or empty string.
 */
export function generatePrefixPlaceholders(prefix: string | undefined): string
⋮----
/**
 * Generates placeholder string based on suffix property.
 * Keys listed in suffix are directly converted to {{key}} placeholders.
 *
 * @param suffix Comma-separated string of property keys (e.g., "finalDirective,signature").
 * @returns Placeholder string (e.g., "\n{{finalDirective}}\n{{signature}}") or empty string.
 */
export function generateSuffixPlaceholders(suffix: string | undefined): string
⋮----
/**
 * Attempts to find a "quick prompt" based on the current selection text or a target identifier.
 * A quick prompt is triggered if the selection text contains a prompt identifier
 * (e.g., "Translate this: quickgpt-translate123") or if a specific identifier is provided.
 * It also cleans the selection text by removing the identifier if found.
 *
 * @param selectionText The currently selected text, potentially containing a prompt identifier.
 * @param identifier An optional specific prompt identifier to look for (e.g., from deeplink arguments).
 * @param filePath Optional file path associated with the prompt call (used if identifier is provided).
 * @returns A tuple: [foundPrompt | undefined, cleanedSelectionText].
 *          `foundPrompt` is the PromptProps object if a quick prompt is identified.
 *          `cleanedSelectionText` is the selection text with the identifier removed (if applicable).
 */
export function getQuickPrompt(
  selectionText: string,
  identifier?: string,
  filePath?: string,
): [PromptProps | undefined, string]
⋮----
/**
 * Builds the final, fully formatted prompt content string.
 * Generates prefix placeholders based on prefix property, prepends these placeholders to the original content,
 * and uses `placeholderFormatter` to substitute all placeholders based on prompt properties and runtime replacements.
 *
 * @param prompt The PromptProps object containing the base content and configuration.
 * @param replacements An object containing the values for standard placeholders (clipboard, selection, etc.).
 * @param relativeRootDir The root directory needed by `placeholderFormatter` to resolve relative `{{file:...}}` paths.
 * @returns The final formatted content string ready to be used (e.g., sent to AI).
 */
export function buildFormattedPromptContent(
  prompt: PromptProps,
  replacements: SpecificReplacements,
  relativeRootDir?: string,
): string
⋮----
/**
 * Determines which placeholder icons (e.g., Clipboard, Text, Globe) should be displayed
 * as accessories for a prompt list item based on the placeholders used in its content
 * and the available replacement values.
 *
 * @param content The raw prompt content string (may contain placeholders).
 * @param replacements An object containing the available replacement values for placeholders.
 * @returns An array of `List.Item.Accessory` objects (containing icons) for the used placeholders.
 */
export function getPlaceholderIcons(
  content: string | undefined,
  replacements: Omit<SpecificReplacements, "clipboard">,
): List.Item.Accessory[]
⋮----
/**
 * Generates a string containing a hierarchically indented list of all prompt titles.
 * Each title is followed by a short summary of its content (first 20 chars).
 * Used for the `{{promptTitles}}` placeholder.
 *
 * @returns A newline-separated string of indented prompt titles and summaries.
 */
export function getIndentedPromptTitles(): string
⋮----
function processPrompt(prompt: PromptProps, level: number = 0)
⋮----
// Get content summary (first 20 characters)
⋮----
// Use original content for summary
⋮----
// Generate prefix and suffix placeholders
⋮----
// Remove newlines and placeholder lines from content for better summary display
⋮----
.replace(/{{.*?}}\n/g, "") // Remove placeholder lines
.replace(/\n/g, " ") // Replace newlines with spaces
⋮----
/**
 * Scan prompt.content to find valid {{option:propertyName}} placeholders
 * Only return property names that actually exist in the prompt object and are non-empty arrays
 *
 * @param prompt The Prompt object to check
 * @returns Array of valid option property names
 */
export function findOptionPlaceholders(prompt: PromptProps): string[]
⋮----
// Simple regex to detect option placeholders
⋮----
// Check if the prompt object itself has this property and it is a non-empty array
⋮----
// Return after deduplication
</file>

<file path="src/prompt-lab.tsx">
import { LaunchProps } from "@raycast/api";
import pinsManager from "./managers/pins-manager";
import promptManager from "./managers/prompt-manager";
import { getQuickPrompt } from "./utils/prompt-formatting-utils";
import { PromptList } from "./components/prompt-list";
import { useInitialContext } from "./hooks/use-initial-context";
import { PromptProps } from "./managers/prompt-manager";
⋮----
interface ExtendedArguments extends Arguments.PromptLab {
  initialSelectionText?: string;
  target?: string;
  actions?: string;
  filePath?: string;
}
⋮----
/**
 * The main entry point component for the QuickGPT Raycast command.
 * It determines the initial context (selection, app, etc.), fetches prompts,
 * handles "quick prompts" based on selection/target, and renders the appropriate PromptList.
 *
 * @param props The launch properties provided by Raycast.
 * @param props.arguments Launch arguments, including potential initial text, target prompt identifier, and allowed actions.
 */
export default function PromptLab(props: LaunchProps<
⋮----
// Convert actions string to array
⋮----
// Get pinned prompts
⋮----
// Get quick prompt
⋮----
// Prepare the list of prompts to display
⋮----
// Determine the effective selected text
⋮----
// Deduplicate the prompt list
⋮----
// Render the prompt list component
</file>

<file path="src/components/prompt-actions.tsx">
import React from "react";
import {
  getPreferenceValues,
  Action,
  Icon,
  Clipboard,
  Toast,
  closeMainWindow,
  showToast,
  Navigation,
} from "@raycast/api";
import { runAppleScript } from "@raycast/utils";
import fs from "fs";
import defaultActionPreferenceStore from "../stores/default-action-preference-store";
import { ScriptInfo } from "../utils/script-utils";
import inputHistoryStore from "../stores/input-history-store";
import { PromptProps } from "../managers/prompt-manager";
import { SpecificReplacements } from "../utils/placeholder-formatter";
import { buildFormattedPromptContent, getIndentedPromptTitles } from "../utils/prompt-formatting-utils";
import {
  updateTemporaryDirectoryUsage,
  updateAnyTemporaryDirectoryUsage,
  removeTemporaryDirectory,
} from "../stores/temporary-directory-store";
import promptManager from "../managers/prompt-manager";
import path from "path";
⋮----
interface Preferences {
  primaryAction: string;
  scriptsDirectory?: string;
  scriptsDirectory1?: string;
  scriptsDirectory2?: string;
}
⋮----
type ActionWithPossibleProps = React.ReactElement<Action.Props & { shortcut?: string; onAction?: () => void }>;
⋮----
interface ActionItem {
  name: string;
  displayName: string;
  condition: boolean;
  action: ActionWithPossibleProps;
}
⋮----
/**
 * Generates a sorted list of Raycast Action elements based on the prompt definition,
 * global preferences, and available scripts. AI actions now trigger a deeplink.
 *
 * @param prompt The prompt object to generate actions for
 * @param baseReplacements Base replacements without clipboard
 * @param promptSpecificRootDir Root directory for file placeholder resolution
 * @param actions An optional array of action names specified in the prompt definition.
 * @param scripts An array of available script information.
 * @param navigation The Navigation object from useNavigation() hook.
 * @param onRefreshNeeded A callback function to be called when the prompt manager needs to refresh
 * @returns An array of React elements representing the sorted Raycast Actions.
 */
⋮----
const wrapActionHandler = (originalHandler: (() => Promise<void>) | undefined | (() => void)) =>
⋮----
// Save input to history if there's any input
⋮----
const getFinalContent = async (): Promise<string> =>
⋮----
onAction=
⋮----
const getNameForSort = (name: string)
</file>

<file path="src/utils/placeholder-formatter.ts">
/**
 * This file provides utility functions for formatting text with placeholders.
 * It supports both synchronous and asynchronous implementations for replacing:
 * - Simple placeholders (input, clipboard, selection, etc.)
 * - File content placeholders for reading files/directories
 * - Fallback handling with alias support
 * - Property path access for referencing prompt object properties
 *
 * The formatter processes placeholders in a two-phase approach for better control:
 * 1. Recursive phase: iteratively resolves property references and fallbacks
 * 2. One-time phase: processes standard context placeholders, files, and options
 */
⋮----
import fs from "fs";
import path from "path";
import { readDirectoryContentsSync } from "./file-system-utils";
⋮----
/* Types & Constants */
⋮----
export type SpecificReplacements = {
  input?: string;
  clipboard?: string;
  selection?: string;
  currentApp?: string;
  allApp?: string;
  browserContent?: string;
  now?: string;
  promptTitles?: string;
};
⋮----
type PlaceholderKey = keyof SpecificReplacements;
type PlaceholderInfo = { alias?: string };
⋮----
/* Utility Functions */
⋮----
const isNonEmpty = (v: unknown): v is string
⋮----
const toPlaceholderKey = (p: string): PlaceholderKey | undefined
⋮----
// Special marker for Finder-selected files
⋮----
/**
 * Determines if a placeholder should be recursively processed in phase 1.
 * Property references and fallback chains not starting with standard placeholder are recursive.
 *
 * @param directive The placeholder directive (file, option, or undefined)
 * @param body The placeholder body text
 * @returns True if this placeholder should be processed recursively
 */
function isRecursivePlaceholder(directive: string | undefined, body: string): boolean
⋮----
if (directive) return false; // file: or option: are not recursive
⋮----
// Check if the first part is a standard placeholder key or alias
⋮----
// If it starts with a standard placeholder (e.g., {{input|prop}}), handle in phase 2, non-recursive
⋮----
// If not starting with a standard placeholder, it's a property reference or property-based fallback (recursive)
⋮----
/**
 * Builds an effective replacement map from raw replacements.
 * Filters out empty values, trims strings, and adds the current time if not present.
 *
 * @param raw The raw replacement values to process
 * @returns A Map of valid placeholder keys to their replacement values
 */
function buildEffectiveMap(raw: Partial<SpecificReplacements> & Record<string, unknown>)
⋮----
// Only process standard placeholder keys defined in SpecificReplacements
⋮----
/* File Placeholder Handling */
⋮----
/**
 * Safely resolves a path to an absolute path, with security checks.
 *
 * @param given The path to resolve
 * @param root The root directory for relative paths
 * @returns The resolved absolute path or an Error if resolution fails
 */
function safeResolveAbsolute(given: string, root?: string): string | Error
⋮----
/**
 * Resolves a file placeholder synchronously, reading file or directory contents.
 * This function escapes any placeholders in the file content to prevent them from being processed.
 *
 * @param body The file path to resolve
 * @param root The root directory for relative paths
 * @returns Formatted string containing file/directory content or error message
 */
function resolveFilePlaceholderSync(body: string, root?: string): string
⋮----
// Escape placeholders in file content by replacing {{ with \\{\\{ to prevent further processing
⋮----
// Use a temporary replacement that's unlikely to exist in the content
⋮----
// Escape placeholders in directory content
⋮----
/**
 * Gets a property value from an object using a dot-notation path.
 * Safely traverses the object hierarchy and returns undefined if any path segment is invalid.
 *
 * @param obj The object to get the property from
 * @param path The dot-notation path (e.g., "title", "subprompts.0.title")
 * @returns The property value, or undefined if the path doesn't resolve
 */
export function getPropertyByPath(obj: unknown, path: string): unknown
⋮----
// Handle array indices
⋮----
// Handle object properties
⋮----
/* Synchronous Placeholder Formatter */
⋮----
/**
 * Formats a string by replacing placeholders with actual values using a two-phase approach:
 * 1. Iteratively resolves property references and fallbacks until stable
 * 2. One-time processing of standard context placeholders, files, and options
 *
 * Special handling for {{selection}} containing file paths from Finder ensures correct file resolution.
 *
 * @param text The text containing placeholders to format
 * @param incoming The replacement values for placeholders and any other properties for p: notation
 * @param root The root directory for file placeholder resolution
 * @param options Additional options for formatting
 * @returns The formatted text with all placeholders replaced
 */
export function placeholderFormatter(
  text: string,
  incoming: SpecificReplacements & Record<string, unknown> = {},
  root?: string,
  options: { resolveFile?: boolean } = { resolveFile: false },
): string
⋮----
// === Phase 1: Iterative processing of property references and fallbacks ===
⋮----
const MAX_ITERATIONS = 10; // Prevent infinite recursion
⋮----
// Continue until no more changes or reach max iterations
⋮----
/* Placeholder Resolution */
⋮----
/**
 * Scans a template and returns the set of *standard* placeholder keys that would be used
 * during formatting with the given replacement values. Ignores property placeholders.
 *
 * @param text The text to scan for placeholders
 * @param standardReplacements The available replacement values (standard placeholders only for icon resolution)
 * @returns A Set of standard placeholder keys (e.g., 'input', 'clipboard') that would be used
 */
export function resolvePlaceholders(
  text: string,
  standardReplacements: Partial<SpecificReplacements> = {},
): Set<PlaceholderKey>
⋮----
/**
 * Helper function to process a single placeholder
 * Used by both sync and async versions to maintain consistent logic
 *
 * @param directive The directive (file, option, or undefined)
 * @param body The placeholder body text (without {{}})
 * @param incoming The replacement values and properties object
 * @param map The processed map of standard placeholders
 * @param root The root directory for file placeholder resolution (optional)
 * @param options Additional options for formatting
 * @returns The processed value for the placeholder
 */
function processPlaceholder(
  directive: string | undefined,
  body: string,
  incoming: SpecificReplacements & Record<string, unknown>,
  map: Map<PlaceholderKey, string>,
  root?: string,
  options: { resolveFile?: boolean } = { resolveFile: false },
): string
⋮----
// Handle fallback chain or single placeholder
⋮----
// Check if this part has a directive (e.g., "option:key" or "file:path")
⋮----
// Not an error message
⋮----
// Handle regular placeholder key
</file>

<file path="package.json">
{
  "$schema": "https://www.raycast.com/schemas/extension.json",
  "name": "quickgpt",
  "title": "QuickGPT",
  "description": "A professional prompt management extension for Raycast that streamlines your workflow by providing efficient access to a comprehensive library of prompts with advanced placeholder capabilities.",
  "icon": "command-icon.png",
  "author": "ddhjy2012",
  "categories": [
    "Productivity"
  ],
  "license": "MIT",
  "commands": [
    {
      "name": "prompt-lab",
      "title": "Prompt Lab",
      "description": "A professional prompt management extension for Raycast that streamlines your workflow by providing efficient access to a comprehensive library of prompts with advanced placeholder capabilities.",
      "mode": "view",
      "preferences": [
        {
          "name": "customPromptsDirectory",
          "title": "Custom Prompts",
          "required": false,
          "description": "Use a custom prompts directory containing your .hjson prompt definition files",
          "type": "directory"
        },
        {
          "name": "customPromptsDirectory1",
          "title": "Custom Prompts 1",
          "required": false,
          "description": "Use the first custom prompts directory containing your .hjson prompt definition files",
          "type": "directory"
        },
        {
          "name": "customPromptsDirectory2",
          "title": "Custom Prompts 2",
          "required": false,
          "description": "Use the second custom prompts directory containing your .hjson prompt definition files",
          "type": "directory"
        },
        {
          "name": "customPromptsDirectory3",
          "title": "Custom Prompts 3",
          "required": false,
          "description": "Use the third custom prompts directory containing your .hjson prompt definition files",
          "type": "directory"
        },
        {
          "name": "customPromptsDirectory4",
          "title": "Custom Prompts 4",
          "required": false,
          "description": "Use the fourth custom prompts directory containing your .hjson prompt definition files",
          "type": "directory"
        },
        {
          "name": "scriptsDirectory",
          "title": "Scripts Directory",
          "required": false,
          "description": "Directory containing AppleScript scripts. All .applescript and .scpt files in this directory will be loaded as executable scripts.",
          "type": "directory"
        },
        {
          "name": "scriptsDirectory1",
          "title": "Scripts Directory 1",
          "required": false,
          "description": "First additional directory containing AppleScript scripts",
          "type": "directory"
        },
        {
          "name": "scriptsDirectory2",
          "title": "Scripts Directory 2",
          "required": false,
          "description": "Second additional directory containing AppleScript scripts",
          "type": "directory"
        },
        {
          "name": "primaryAction",
          "title": "Actions",
          "required": false,
          "description": "Set the primary action(s) to execute, separated by commas. Example: Copy, Paste, MyScript",
          "type": "textfield"
        },
        {
          "name": "customEditor",
          "title": "Editor Application",
          "description": "Select the application to open and edit prompt files (`.hjson`).",
          "type": "appPicker",
          "required": true,
          "default": "com.todesktop.230313mzl4w4u92"
        }
      ]
    }
  ],
  "dependencies": {
    "@raycast/api": "^1.96.0",
    "@raycast/utils": "^1.19.0",
    "@types/hjson": "^2.4.6",
    "hjson": "^3.2.2",
    "ignore": "^5.3.1",
    "markdown-it": "^14.1.0",
    "md5": "^2.3.0",
    "pinyin-pro": "^3.16.3"
  },
  "devDependencies": {
    "@raycast/eslint-config": "^1.0.8",
    "@testing-library/jest-dom": "^6.5.0",
    "@types/jest": "^29.5.14",
    "@types/markdown-it": "^14.1.2",
    "@types/md5": "^2.3.4",
    "@types/node": "20.8.10",
    "@types/react": "^19.1.2",
    "eslint": "^8.57.0",
    "jest": "^29.7.0",
    "prettier": "^3.3.3",
    "react": "^19.1.0",
    "ts-jest": "^29.2.5",
    "typescript": "^5.8.3"
  },
  "scripts": {
    "build": "ray build -e dist -o dist",
    "dev": "ray develop",
    "fix-lint": "ray lint --fix",
    "lint": "ray lint",
    "publish": "npx @raycast/api@latest publish",
    "format": "prettier --write .",
    "test": "jest",
    "test:watch": "jest --watch"
  }
}
</file>

<file path="src/components/prompt-list-item.tsx">
import React, { useMemo, useState, useEffect } from "react";
import {
  List,
  ActionPanel,
  Icon,
  Action,
  Color,
  showToast,
  Toast,
  closeMainWindow,
  openExtensionPreferences,
  getPreferenceValues,
  Clipboard,
  Image,
  useNavigation,
  Application,
} from "@raycast/api";
import { runAppleScript } from "@raycast/utils";
import { PromptProps } from "../managers/prompt-manager";
import { SpecificReplacements } from "../utils/placeholder-formatter";
import path from "path";
import { generatePromptActions } from "./prompt-actions";
import { getPlaceholderIcons, findOptionPlaceholders } from "../utils/prompt-formatting-utils";
import { findUsedOptionPlaceholders } from "../utils/option-placeholder-utils";
import { ScriptInfo } from "../utils/script-utils";
import { placeholderFormatter } from "../utils/placeholder-formatter";
import { PromptList } from "./prompt-list";
import { PromptOptionsForm } from "./prompt-options-form";
import { TemporaryDirectoryManager } from "./temporary-directory-manager";
import {
  removeTemporaryDirectory,
  getActiveTemporaryDirectoriesWithExpiry,
  TemporaryDirectoryWithExpiry,
} from "../stores/temporary-directory-store";
import promptManager from "../managers/prompt-manager";
import inputHistoryStore from "../stores/input-history-store";
⋮----
interface QuickGPTExtensionPreferences {
  customPromptsDirectory?: string;
  customPromptsDirectory1?: string;
  customPromptsDirectory2?: string;
  customPromptsDirectory3?: string;
  customPromptsDirectory4?: string;
  scriptsDirectory?: string;
  scriptsDirectory1?: string;
  scriptsDirectory2?: string;
  customEditor: Application;
}
⋮----
interface PromptListItemProps {
  prompt: PromptProps;
  index: number;
  replacements: Omit<SpecificReplacements, "clipboard">;
  searchMode?: boolean;
  promptSpecificRootDir?: string;
  allowedActions?: string[];
  onPinToggle: (prompt: PromptProps) => void;
  activeSearchText?: string;
  scripts: ScriptInfo[];
  onRefreshNeeded: () => void;
  addToHistory?: (input: string) => void;
  setCurrentInput?: (input: string) => void;
}
⋮----
/**
 * Renders a single item in the prompt list.
 * Generates the appropriate UI and ActionPanel based on the prompt type (regular, folder, options, special).
 *
 * @param props The component props.
 * @param props.prompt The prompt data for this list item.
 * @param props.index The index of the item in the list.
 * @param props.replacements Base replacements without clipboard.
 * @param props.searchMode Indicates if the parent list is in search mode.
 * @param props.promptSpecificRootDir The specific root directory containing this prompt, if applicable.
 * @param props.allowedActions Optional list of allowed action names for this prompt.
 * @param props.onPinToggle Callback function to handle pinning/unpinning.
 * @param props.activeSearchText The current text in the search bar (if not in search mode).
 * @param props.scripts List of available scripts.
 * @param props.onRefreshNeeded Callback function to refresh the prompt list.
 */
⋮----
// index parameter not used, but kept for interface consistency
// eslint-disable-next-line @typescript-eslint/no-unused-vars
⋮----
// Clean up timer when component unmounts
⋮----
// Apply placeholder formatting to the actual prompt title
⋮----
// Initialize displayTitle with the formatted actual title
⋮----
// Apply special formatting only in searchMode and if the prompt has a path (is nested)
⋮----
// pathComponents includes the final title, e.g., ["一级", "二级", "Prompt B"]
const hierarchyDepth = pathComponents.length; // Total depth including the title
⋮----
// Only add prefix if there's at least one parent directory
⋮----
// Add "..." if original depth was 3 or more (e.g., Top/Mid/Title)
⋮----
// Combine prefix and the actual formatted title
⋮----
// If hierarchyDepth is 1, it means no parent directory, so displayTitle remains formattedActualTitle
⋮----
// Dynamic title and icon
⋮----
// Handle Settings related options icons
⋮----
// Memoize placeholder icons
⋮----
// Memoize prompt actions
⋮----
onAction=
⋮----
// Actions for folder type prompts
⋮----
// 1. Open folder action (usually the primary action)
⋮----
icon={prompt.icon ?? Icon.Folder} // Icon.FolderOpen would be more appropriate
⋮----
allowedActions={allowedActions || prompt.actions} // These are actions for sub-items
⋮----
externalOnRefreshNeeded={onRefreshNeeded} // Pass refresh callback
⋮----
// 2. If sourced from temporary directory, add action to remove source directory
⋮----
const tempDirSourcePath = prompt.temporaryDirSource; // Closure capture
⋮----
icon={Icon.Eject} // Or Icon.Trash
⋮----
removeTemporaryDirectory(tempDirSourcePath);
promptManager.reloadPrompts();
if (onRefreshNeeded)
onRefreshNeeded();
⋮----
// If the current view is this folder or its children, go back to the previous level
⋮----
return <>{folderActions}</>; // Return wrapped in React Fragment
⋮----
// Default actions for regular prompts
// Check which option placeholders would actually be used given current replacements
⋮----
// Action for prompts with option placeholders that would actually be used
⋮----
// Action for prompts defined with options object (needs options form)
⋮----
// Generate standard actions
⋮----
// Create accessories to display remaining time
⋮----
// For settings-related options, don't display any accessory icons
⋮----
// Refresh the list by re-creating it
⋮----
// Read clipboard history (up to 6 items)
⋮----
// If reading fails, no more history available
⋮----
// Use React.memo to prevent unnecessary re-renders
⋮----
// Create an array of all possible prompt directories
⋮----
// If there's only one directory, open it directly
⋮----
// If there are multiple directories, provide actions for each
⋮----
closeMainWindow();
⋮----
console.error(`Failed to open prompt directory $
await showToast(Toast.Style.Failure, "Error opening directory");
</file>

<file path="CHANGELOG.md">
# quickgpt Changelog

## [Next Version] - YYYY-MM-DD

### Added

- Added input history feature that automatically saves previously entered inputs. Access history using Cmd+Y shortcut in input mode. History stores up to 50 most recent unique inputs.
- Added `suffix` property, similar to `prefix`, but appends placeholders to the end of content. Usage is the same as `prefix`, with comma-separated property key list, e.g. `suffix: "finalNote, signature"`.
- Adds the ability to select a temporary directory as a source for prompts.
- Adds a new `{{option:key}}` placeholder allowing users to create dynamic dropdowns within prompts based on prompt attributes. See [README](https://github.com/your-repo/quickgpt-raycast#dynamic-options-placeholder-optionkey) for details.
- Add support for global variables via `config.json`.
- Added an action to remove the temporary directory containing the "Manage Temporary Directory" prompt itself, if it comes from a temporary directory.
- Added action options for all prompts sourced from temporary directories (not just "Manage Temporary Directory" prompt), allowing users to remove the containing temporary directory directly from the prompt's action panel.
- Added "Editor Application" preference setting that allows users to select their preferred application for opening prompt files via an app picker. Defaults to Cursor.

### Fixed

- Fixed an issue where the options configuration page was empty when using `{{option:key}}` placeholder in prompts. Now correctly displays dropdown options generated from prompt property arrays.
- Fix an issue where relative paths (`[Path not found: relative/path]`) in prompts located within a Temporary Directory failed to resolve, causing a 'Root directory not configured for relative path:' error. Relative paths now correctly resolve against their containing temporary directory.
- Fix the issue where the `model` field in `config.json` was not taking effect.
- Fix an issue where the `currentApp` placeholder would not be replaced if the active application changed while Raycast was open.

### Changed

- **Refactored file naming convention**: Adopted kebab-case (hyphen-separated) as the unified file naming convention to improve project consistency
  - Renamed all Component files (e.g., `PromptActions.tsx` → `prompt-actions.tsx`)
  - Renamed all Hook files (e.g., `useInitialContext.ts` → `use-initial-context.ts`)
  - Renamed all Manager files (e.g., `PromptManager.ts` → `prompt-manager.ts`)
  - Renamed all Store files (e.g., `TemporaryPromptDirectoryStore.ts` → `temporary-directory-store.ts`)
  - Renamed all Utils files (e.g., `fileSystemUtils.ts` → `file-system-utils.ts`)
  - Updated all related import statements to match the new file names
- Settings-related options now use system icons instead of emojis, including "Open custom prompts directory", "Open scripts directory", and "Open preferences", for consistency with "Manage Temporary Directory".
- Temporary directory expiration time changed from 1 day to 7 days.
- Improved display of remaining time for temporary directories to show days, hours, and minutes as appropriate.
- **Refactored placeholder parsing logic:**
  - Property reference placeholders (`{{propertyName}}`) and fallback placeholders not starting with standard context (`{{ph1|ph2|...}}`) are now recursively parsed until stable.
  - Standard context placeholders (`{{input}}`, `{{clipboard}}` etc.), **raw** file content placeholders (`{{file:path}}`), and dynamic option placeholders (`{{option:key}}`) are parsed only once after recursive parsing is complete.
  - **Precise file selection handling:** Internally distinguishes the source of `{{selection}}` values using markers. Only `{{file:path}}` generated from **Finder file selections** will be further parsed to load content when needed. If user selects literal text `{{file:path}}`, file parsing is not triggered.
- Changed "Custom Editor Command" preference to "Editor Application", using app picker to let users more conveniently select the editor for editing prompt files.
- **Optimized file ignore logic:**
  - Created unified `IgnoreManager` singleton class to manage all file ignore rules
  - Enhanced `.gitignore` support to recursively find and apply all parent directory `.gitignore` files
  - Implemented ignore rule caching mechanism to improve performance
  - Support for custom ignore rule extensions
  - Unified handling of binary file detection and ignore pattern matching
</file>

<file path="README.md">
# QuickGPT for Raycast

[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/AsyncFuncAI/deepwiki-open)
[![License: Apache 2.0](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)

A professional prompt management extension for Raycast that **streamlines** your workflow by providing efficient access to a comprehensive library of **prompts** with advanced placeholder capabilities.

1. **streamlines**: Integrated with PopClip and Gemini, a prompt is a tool

<video src="https://github.com/user-attachments/assets/e1a222b3-2df2-496f-bf8d-7726f7fab5d0">
</video>

1. **prompts**: Management 200+ prompts with HJSON format and git version control, develop prompts like a project

<img src="https://github.com/user-attachments/assets/d94fc5b5-4e9a-41e9-abd4-ff5c48c601d6" alt="图片描述" >

## Overview

QuickGPT is a sophisticated prompt management tool designed specifically for Raycast. It enables users to organize, access, and utilize extensive prompt libraries directly within the Raycast interface. The extension supports dynamic content injection through an advanced placeholder system and seamlessly integrates with various applications and workflows.

## Key Features

### Advanced Prompt Management

- **HJSON Format Support**: Utilize the human-readable HJSON format (`.hjson`) for defining prompts, enabling version control and collaborative development
- **Hierarchical Organization**: Structure prompts in nested folders for better organization and accessibility
- **Temporary Directories**: Add temporary prompt directories with automatic expiration (7 days)
- **Multiple Source Directories**: Configure up to 5 custom prompt directories for different contexts or projects

### Sophisticated Placeholder System

- **Context-Aware Placeholders**: `{{input}}`, `{{selection}}`, `{{clipboard}}`, `{{currentApp}}`, `{{allApp}}`, `{{browserContent}}`, `{{now}}`, `{{promptTitles}}`
- **File Content Integration**: `{{file:path/to/file}}` for including external file contents
- **Dynamic Options**: `{{option:key}}` for creating interactive dropdown menus
- **Fallback Logic**: `{{selection|clipboard}}` for intelligent placeholder resolution
- **Property References**: Access prompt properties directly using `{{propertyName}}` notation

### Integration Capabilities

- **System-Wide Accessibility**: Invoke QuickGPT from any application via Raycast
- **AppleScript Support**: Execute custom AppleScript files as actions
- **Clipboard Management**: Seamless copy/paste operations with formatted content

## Installation

### Prerequisites

- macOS with [Raycast](https://www.raycast.com/) installed
- Node.js 20.8.10 or higher
- npm or yarn package manager

### Installation Steps

1. **Clone the Repository**

   ```bash
   git clone https://github.com/ddhjy/quickgpt-raycast.git
   cd quickgpt-raycast
   ```

2. **Install Dependencies**

   ```bash
   npm install
   ```

3. **Build the Extension**

   ```bash
   npm run dev
   ```

## Configuration

Configure QuickGPT through Raycast Preferences (`Raycast Settings > Extensions > QuickGPT`):

### Prompt Directories

- **Custom Prompts**: Primary directory for prompt files
- **Custom Prompts 1-4**: Additional directories for organizing prompts by context

**Recommended Setup**: To get started quickly, configure your first prompt directory to point to the included example:

[example/prompt/](example/prompt/)

This directory contains a comprehensive `prompt-template.hjson` file that demonstrates:

- Advanced placeholder usage (`{{input}}`, `{{selection}}`, `{{option:key}}`)
- Nested subprompts with hierarchical organization
- Dynamic dropdown options and property references
- Professional writing assistant templates

### Scripts Directory

- **Scripts Directory**: Location for AppleScript files (`.applescript`, `.scpt`)

**Recommended Setup**: Configure the scripts directory to:

[example/script/](example/script/)

### Actions Configuration

- **Actions**: Comma-separated list of default actions (e.g., `Copy,Paste,OpenAI`)

### Editor Settings

- **Editor Application**: Select the application for editing prompt files

## Usage

### Basic Operation

1. **Launch QuickGPT**

   - Activate Raycast and type the command alias (default: `prompt` or `quickgpt`)

2. **Browse and Search**

   - Navigate through prompts using arrow keys
   - Search by typing (supports Pinyin matching)
   - Pin frequently used prompts with `⌘ + Shift + P`

3. **Input Modes**

   - **Search Mode**: Browse and filter prompts
   - **Input Mode**: Type text followed by space to provide input for `{{input}}` placeholder

4. **Execute Actions**
   - Press `⌘ + K` to open the Action Panel
   - Use `⌘ + Enter` for the default action
   - Available actions include Copy, Paste, Script execution, and AI service calls

### Advanced Features

#### Temporary Directories

Add temporary prompt directories that automatically expire after 7 days:

1. Select a directory in Finder
2. Choose "Manage Temporary Directory" from the Settings menu
3. Select "Add Temporary Directory from Finder"

#### Deeplinks

Access specific prompts directly using deeplinks:

```
raycast://extensions/ddhjy2012/quickgpt/prompt-lab?arguments={"target":"quickgpt-[identifier]"}
```

## Prompt File Format

Prompts are defined in HJSON files with the following structure:

```hjson
{
  // Required: Display title
  title: "Translation Assistant"

  // Optional: Unique identifier for pinning and deeplinks
  identifier: "translate_v1"

  // Optional: Icon (emoji or SF Symbol)
  icon: "globe"

  // Required: Main prompt content with placeholders
  content: '''
  Translate the following text into {{option:languages}}:

  {{selection|clipboard}}
  '''

  // Optional: Preferred actions for this prompt
  actions: ["Copy", "Paste"]

  // Optional: Array property for dropdown options
  languages: ["French", "Spanish", "German", "Japanese"]

  // Optional: Property key references for prefix/suffix
  prefix: "responseFormat,tone"
  suffix: "signature"

  // Optional: Properties referenced by prefix/suffix
  responseFormat: "Provide a clear and concise response"
  tone: "Professional tone"
  signature: "Generated by QuickGPT"
}
```

### Nested Prompts

```hjson
{
  title: "Writing Tools"
  icon: "pencil"
  identifier: "writing_tools"

  // Inheritable properties
  prefix: "tone"
  tone: "Professional writing style"

  subprompts: [
    {
      title: "Grammar Check"
      identifier: "grammar_check"
      content: "Check and improve grammar: {{selection}}"
      // Inherits prefix from parent
    }
    {
      title: "Summarize"
      identifier: "summarize"
      content: "Summarize: {{selection}}"
      prefix: "length" // Overrides parent prefix
      length: "Keep it under 100 words"
    }
  ]
}
```

## Placeholder Reference

| Placeholder          | Alias    | Description                                        |
| -------------------- | -------- | -------------------------------------------------- |
| `{{input}}`          | `{{i}}`  | Text entered in Raycast input field                |
| `{{clipboard}}`      | `{{c}}`  | Current clipboard content                          |
| `{{selection}}`      | `{{s}}`  | Selected text or Finder items                      |
| `{{currentApp}}`     |          | Name of frontmost application                      |
| `{{allApp}}`         |          | Comma-separated list of all installed applications |
| `{{browserContent}}` |          | Markdown content from active browser tab           |
| `{{now}}`            | `{{n}}`  | Current date and time                              |
| `{{promptTitles}}`   | `{{pt}}` | Indented list of all prompt titles                 |
| `{{file:path}}`      |          | File or directory content                          |
| `{{option:key}}`     |          | Dropdown selection from array property             |
| `{{property}}`       |          | Value from prompt property                         |
| `{{ph1\|ph2}}`       |          | Fallback chain (first non-empty value)             |

### Fallback Chains with Directives

You can use `option:` and `file:` directives within fallback chains:

- `{{i|option:type}}` - Use input if available, otherwise use the first value from the `type` option array
- `{{i|file:config.txt}}` - Use input if available, otherwise load content from `config.txt`
- `{{selection|file:template.md|clipboard}}` - Try selection first, then file content, finally clipboard

Example in HJSON:

```hjson
{
  title: "Example Prompt"
  content: "Process this: {{i|option:defaultType}}"
  defaultType: ["text", "code", "markdown"]
}
```

Placeholder usage example:

[example/prompt/prompt-template.hjson](example/prompt/prompt-template.hjson)

## Development

### Project Structure

```
quickgpt-raycast/
├── src/
│   ├── components/     # React components
│   ├── hooks/         # Custom React hooks
│   ├── managers/      # Core managers (Prompt, Pins)
│   ├── stores/        # Data stores
│   ├── utils/         # Utility functions
│   └── prompt-lab.tsx # Main entry point
├── assets/            # Static assets and default prompts
├── package.json       # Project configuration
└── tsconfig.json     # TypeScript configuration
```

### Available Scripts

```bash
npm run build    # Build for production
npm run dev      # Development mode with hot reload
npm run lint     # Run ESLint
npm run format   # Format code with Prettier
npm run test     # Run tests
```

### Testing

The project uses Jest for unit testing. Run tests with:

```bash
npm test
```

## Contributing

Contributions are welcome. Please follow these guidelines:

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/your-feature`)
3. Commit your changes (`git commit -am 'Add new feature'`)
4. Push to the branch (`git push origin feature/your-feature`)
5. Create a Pull Request

### Code Style

- TypeScript with strict mode enabled
- ESLint configuration extends `@raycast`
- Prettier for code formatting
- Comprehensive JSDoc comments

## License

This project is licensed under the Apache License 2.0. See the [LICENSE](LICENSE) file for details.

## Support

For bug reports and feature requests, please use the [GitHub Issues](https://github.com/ddhjy/quickgpt-raycast/issues) page.

## Acknowledgments

Built for the Raycast community to enhance productivity and streamline AI-powered workflows.
</file>

</files>
